#library "FLOPPY" // Name of the library
#include "zcommon.acs"

//WARNING: Zandronum will potentially crash if you host a checkpoint chugging contest.

//////////////////////////////////////////////////////////////
//						SAVE DISK START						//
//////////////////////////////////////////////////////////////
#define SP_DISK_TID 32035
#define SP_MAXPLAYERS 64

script "checkpoint_warp_connected" ENTER
{
	ACS_NamedExecuteAlways("checkpoint_warp",0);
}

//Warps player to checkpoint set and Gives sp_PowerLoad to player
script "checkpoint_warp" RESPAWN
{
if(!sp_PlayerKeyDown(-1, BT_ZOOM) && GetCvar("sp_ZCancel") == TRUE || !GetCvar("sp_ZCancel"))
	{
		IF (sp_ActorExists(SP_DISK_TID))
		{
		if(GetCvar("sp_ProtectActivator") == TRUE)
		{
		GiveInventory ("sp_PowerLoad", 1);
		}
		//Teleport(SP_DISK_TID, 0, 1);
		SetHudSize(320,240,0);
		until (sp_PlayerKeyDown(-1, BT_ZOOM) && !GetCvar("sp_ZCancel") || sp_RoomForWarp())
			{
				HudMessageBold(s:""; HUDMSG_PLAIN, 880, 0, 0.0, 0.0, 0.0, 0.0);
				if (GetCvar("sp_ZCancel") == TRUE)
				{
				HudMessage(s:"\c[Chlorine]            Waiting to warp...\n Hold the Zoom Key to cancel."; HUDMSG_FADEOUT | HUDMSG_COLORSTRING, 0,"Chlorine", 160.0, 190.0, 1.0, 2.0);
				}
				else
				{
				HudMessage(s:"\c[Chlorine]            Waiting to warp..."; HUDMSG_FADEOUT | HUDMSG_COLORSTRING, 0,"Chlorine", 160.0, 190.0, 1.0, 2.0);
				}
				delay(35);
			}
		SetHudSize(0, 0, FALSE);
		//SetActorPosition(0, GetActorX(SP_DISK_TID), GetActorY(SP_DISK_TID), GetActorZ(SP_DISK_TID), TRUE);
		if(!sp_PlayerKeyDown(-1, BT_ZOOM) && GetCvar("sp_ZCancel") == TRUE || !GetCvar("sp_ZCancel"))
			{
			FadeTo(0, 0, 160,Random(0.25,0.38), 0.0);
			FadeTo(0, 0, 0, 0.0, 0.3);
			ChangeActorAngle(0,Random(0.0,1.0));
			ThrustThingZ(0, Random(GetCvar("sp_SpawnVelocityZ_Min"),GetCvar("sp_SpawnVelocityZ_Max")), 0, 0);
			ThrustThing(Random(0,256),GetCvar("sp_SpawnVelocityXY"), 1, 0);
			}
		}
	}
}

//Clears previous checkpoints.
script "checkpoint_wipe" (void)
{
	if (sp_ActorExists(SP_DISK_TID))
	{
	thing_remove(SP_DISK_TID);
	}
	terminate;
}

//Logs "[PLAYERNAME] just hit a checkpoint!" and revives everyone.
script "checkpoint_hit" (void)
{
	if(GetCvar("sp_ProtectActivator") == TRUE)
	{
		GiveInventory ("sp_PowerSaved", 1);
	}

	if (GameType() != GAME_SINGLE_PLAYER)
	{
		HudMessageBold(s:""; HUDMSG_PLAIN, 880, 0, 0.0, 0.0, 0.0, 0.0);
		SetHudSize(320,240,0);
		HudMessageBold (s:"\c[Chlorine]",n:0,s:" just hit a checkpoint!"; HUDMSG_FADEOUT | HUDMSG_COLORSTRING | HUDMSG_LOG, 880,"Chlorine", 160.0, 62.0, 1.0, 2.0);
		SetHudSize(0, 0, FALSE);
		AmbientSound("SP_CHECK", 127);
	}
	else
	{
		AmbientSound("SP_SAVED", 127);
	}

	FadeTo(0, 0, 160,0.25, 0.0);
	FadeTo(0, 0, 0, 0.0, 0.3);
}

script "sp_init_revive_all" (void)
{
ACS_NamedExecute("sp_revive_all", 0,GetCvar("sp_ResDelay"));
}

//Revives all players.
script "sp_revive_all" (int time)
{
	delay(35);
	int i = 0;
		 while (i<SP_MAXPLAYERS)
		 {
			SetDeadSpectator(i,FALSE);
			i++;
			delay(time);
		 }
}

script "iamlegend" (void)
{
	int i = 1;
		 while (i<SP_MAXPLAYERS)
		 {
			SetDeadSpectator(i,TRUE);
			i++;
			delay(1);
		 }
}

script "sp_getlocation" (void) NET
{
LocalAmbientSound("SP_SAVED", 127);
print(s:"X: ",f:GetActorX(0),s:"\nY: ",f:GetActorY(0),s:"\nZ: ",f:GetActorZ(0));
Log(s:"PlaceCheckpoint(",f:GetActorX(0),s:",",f:GetActorY(0),s:",",f:GetActorZ(0),s:");");
}

// Modified from acsutils
function bool sp_PlayerKeyDown(int player, int key)
{
	int buttons = GetPlayerInput(player, INPUT_BUTTONS);

	if ((buttons & key) == key) { return TRUE; }
		return FALSE;
}

function bool sp_RoomForWarp(void)
{
	if (!SetActorPosition(0, GetActorX(SP_DISK_TID), GetActorY(SP_DISK_TID), GetActorZ(SP_DISK_TID), TRUE))
		return FALSE;
	return TRUE;
}

function bool sp_ActorExists(int tid)
{
	if (tid != 0)
		return ClassifyActor(tid) != ACTOR_NONE;
	return sp_notflag(ClassifyActor(tid), ACTOR_WORLD);
}

function bool sp_notflag(int flags, int flag)
{
	return !(flags & flag);
}
//TODO Add a function to move all players to an activators position.
//	   Add a function to move all players to the active checkpoint.

//////////////////////////////////////////////////////////////
//						SAVE DISK END						//
//////////////////////////////////////////////////////////////